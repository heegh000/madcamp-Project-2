# DataBase

---

유저 정보를 저장하는 “user_info”와 유저의 전적을 저장하는 “history” 두 개의 테이블를 운영합니다.

## user_info

1. user_id : 유저의 아이디 저장, 고유 값이므로 primary key로 지정. 
2. user_pw : local 회원에 한해 유저의 비밀번호를 암호화하여 저장 
3. user_nickname : 유저가 설정한 닉네임 저장
4. gold : 유저가 가지고 있는 골드 저장
5. . avatar_id : 유저가 사용 중인 프로필 사진의 index를 저장
6. user_email : 구글 회원에 한하여 유저의 이메일을 저장

## history

1. user_id : 유저 아이디를 저장, user_info의 user_id를 참조하는 foreign key로 지정
2. time : 게임이 종료된 시점을 저장
3. result : 게임의 결과를 저장

# HTTP 통신

---

회원 가입, 로그인, 전적, 랭킹 등 실시간일 필요 없는 통신에는 HTTP 통신을 사용하기로 하였습니다.

## Local 회원

---

### 회원 가입

- Local 회원 가입 요청이 들어오면, DB에 접근하여 동일한 아이디가 존재하는 지를 판단합니다.
- 만약 DB에 이미 동일한 아이디가 존재한다면, 클라이언트에게 회원 가입 거부 결과을 전달합니다.
- 회원 가입이 가능하면, Local 회원의 아이디, 비밀번호, 닉네임, 현재 골드, 아바타에 대한 정보를 DB에 저장합니다. Local 회원은 이메일을 저장하지 않으며, 비밀번호만 저장합니다.

### 로그인

- 클라이언트로부터 받은 아이디와 비밀번호를 DB와 대조하여 일치한다면 클라이언트에게 로그인 승인 결과를 전달합니다.

## 구글 회원

---

### 회원 가입

- 구글 로그인 요청이 들어오면, DB에 접근하여 동일한 아이디가 존재하는 지를 판단합니다.
- 만약 DB에 이미 동일한 아이디가 존재한다면, 클라이언트에게 회원 가입 거부 결과를 전달합니다.
- 회원 가입이 가능하고, 구글 로그인이 처음이라면, 아이디, 이메일, 닉네임, 현재 골드, 아바타에 대한 정보를 DB에 저장합니다.  구글 회원은 비밀번호를 저장하지 않으며, 이메일만 저장한다.

# 

- 회원 가입이 가능하고 구글 로그인이 처음이 아니라면, DB와 대조하여 아이디와 같은 회원의 이메일과 비밀번호를 확인합니다.
- 만약 이메일이 있다면 구글 회원이므로 클라이언트에게 로그인 승인 결과를 전달합니다.
- 만약 비밀번호가 있다면 Local 회원이므로 클라이언트에게 로그인 거부 결과를 전달합니다.

## 전적

- 요청과 함께 받은 아이디를 이용하여 DB에 접근합니다. 아이디와 일치하는 게임 종료 시간과 게임 결과를 클라이언트에게 전달합니다.

## 랭킹

- DB의 회원들을 gold를 기준으로 내림차순 정렬한 후, 상위 20명에 대한 닉네임, 현재 골드, 아바타에 대한 정보를 클라이언트에게 전달합니다.

### 메인 화면

- 클라이언트가 메인 화면에 도착할 때마다, 유저에 대한 정보를 요청합니다.
- 요청과 함께 받은 아이디를 이용하여 DB에 접근합니다. 아이디와 일치하는 닉네임, 현재 골드, 아바타에 대한 정보, 랭킹을 클라이언트에게 전달합니다.

# 게임 요청 처리

---

게임 구현에 있어 HTTP 통신의 단방향성때문에 소켓 통신을 이용하기로 하였습니다. nodeJS의 [socket.io](http://socket.io) 라이브러리를 이용하였습니다.

## 게임 참가

- 클라이언트에서 게임 참가 요청이 도착한다면(”join”) 요청이 온 소켓을 비어있는 room에 추가한 뒤, 현재 room에 존재하는 소켓의 수를 클라이언트에게 전달합니다.
- 방에 대한 정보 ( 참가한 유저의 정보, 투표 수, 살아남은 사람의 수 등등)은 in-memory 자료구조로 관리합니다.
- 참가한 유저의 정보에는 클라이언트의 유저 아이디, 소켓 아이디, 비상금 등이 있습니다.
- 만약 room에 존재하는 소켓의 수가 5개가 된다면 그 room에 존재하는 클라이언트들에게 게임이 시작된다는 이벤트를 전달합니다.

## 금화 배분

- 현재 우선순위가 가장 높은 클라이언트 보낸 금화 배분 정보가 서버에 도착한다면(”offer”), 서버는 같은 room에 속한 클라이언트들에게 금화 배분 정보를 전달합니다.
- in-memory 자료구조에 금화 배분 정보를 업데이트합니다.

## 메시지

- 클라이언트로부터 메시지 요청이 도착한다면(”msg”), in-memory 자료 구조를 통해 수신자의 소켓 아이디를 구합니다.
- 수신자의 소켓 아이디를 이용하여, 수신자에게 메시지 내용을 전달합니다.

## 투표

- 클라이언트로부터 투표 요청이 도착한다면(”vote”), in-meomry 자료 구조를 통해 현재 투표 수와 찬성/반대 수를 업데이트 합니다.
- 만약 살아남은 사람들이 모두 투표를 하였다면, 서버는 찬성/반대 수를 통해 결과에 따라 다음과 같은 이벤트를 클라이언트에게 전달합니다.
    1. 과반 초과 찬성: room에 존재하는 모든 클라이언트들에게 거래가 성립되었다는 정보(”offer_accept”)를 전달합니다.
    2. 과반 이상 반대: 거래를 제안한 클라이언트에게는 사망하였다는 정보(”dead”), 살아남은 클라이언트들에게는 거래가 성립되지 않았다는 정보(”offer_reject”)를 전달합니다.
    3. 만약 두 명의 클라이언트만 살아남았다면 그 둘에게 해적의 딜레마(”dilemma”) 시작하라는 이벤트를 전달합니다.

## 해적의 딜레마

- 두 명의 클라이언트가 남았을 때 처리해야 하는 이벤트입니다. 죄수의 딜레마를 모티브로 하여, 클라이언트로부터 찬성/반대를 받습니다.
- 두 클라이언트에게 찬성을 받았다면 클라이언트에게 거래가 성립되었다는 정보(”offer_accept”)를 전달합니다.
- 두 클라이언트에게 반대를 받았다면 클라이언트에게 사망하였다는 정보(”dead”)를 전달합니다.
- 둘 중 한 명의 클라이언트만 찬성하였다면 찬성한 클라이언트에게는 사망하였다는 정보를, 반대한 클라이언트에게는 거래가 성립되었다는 정보를 전달합니다.

## 게임 종료

- 거래가 성립되었다는 정보를 받은 클라이언트는 서버에게 자신의 현재 비상금과 함께 이벤트를 보냅니다.
- 사망하였다는 정보를 받은 클라이언트 역시 서버에게 이벤트를 보냅니다.
- 이벤트를 받은 서버는 DB의 user_info의 gold 정보를 업데이트하고, history의 방금 게임의 결과를 저장합니다.
